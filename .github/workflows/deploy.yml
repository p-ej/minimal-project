name: deploy

# ì´ ì›Œí¬í”Œë¡œëŠ” ë©”ì¸ ë¸Œëœì¹˜ë¡œì˜ ë³€ê²½ ì¤‘, ë°°í¬ì— ì˜í–¥ ìˆëŠ” íŒŒì¼ ìˆ˜ì •ì´ ìˆì„ ë•Œë§Œ ì‹¤í–‰ë©ë‹ˆë‹¤.
# ë˜í•œ ìˆ˜ë™ ì‹¤í–‰(workflow_dispatch)ë„ ì§€ì›í•©ë‹ˆë‹¤.
on:
  push:
    branches: [ master ]
    paths:
      - 'src/**'                 # ì•± ì†ŒìŠ¤ ë³€ê²½ ì‹œ
      - 'package.json'           # ì˜ì¡´ì„±/ìŠ¤í¬ë¦½íŠ¸ ë³€ê²½ ì‹œ
      - 'package-lock.json'      # ì˜ì¡´ì„± ì ê¸ˆ íŒŒì¼ ë³€ê²½ ì‹œ
      - 'Dockerfile'             # ë„ì»¤ ë¹Œë“œ ì •ì˜ ë³€ê²½ ì‹œ
      - 'ecs-task-def.json'      # ECS íƒœìŠ¤í¬ ì •ì˜ ë³€ê²½ ì‹œ
  workflow_dispatch:             # ìˆ˜ë™ íŠ¸ë¦¬ê±°

# ë™ì¼ ë¸Œëœì¹˜ì—ì„œ ì¤‘ë³µ ì‹¤í–‰ë˜ëŠ” ë°°í¬ ì¡ì€ ìµœì‹  ì‹¤í–‰ë§Œ ìœ ì§€í•˜ê³  ë‚˜ë¨¸ì§€ëŠ” ì·¨ì†Œí•©ë‹ˆë‹¤.
concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # ----- CI ë‹¨ê³„: íƒ€ì… ì²´í¬ë§Œ ìˆ˜í–‰ (ë¹Œë“œëŠ” Dockerì—ì„œë§Œ) -----
  ci:
    name: Type check only
    runs-on: ubuntu-latest
    steps:
      # 1) ì €ì¥ì†Œ ì²´í¬ì•„ì›ƒ
      - name: Checkout
        uses: actions/checkout@v4

      # 2) Node ì„¤ì •
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      # 2-1) npm ìºì‹œ ëª…ì‹œì  ì„¤ì • (setup-nodeì˜ cacheë³´ë‹¤ ë” ì„¸ë°€í•œ ì œì–´ ê°€ëŠ¥)
      - name: Cache npm dependencies
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-

      # 3) ì˜ì¡´ì„± ì„¤ì¹˜ (package-lock.json ê¸°ì¤€ ì¬í˜„ì„± ë³´ì¥)
      - name: Install dependencies
        run: npm ci

      # 4) íƒ€ì… ì²´í¬ë§Œ ìˆ˜í–‰ (ë¹Œë“œëŠ” Dockerì—ì„œ í•œ ë²ˆë§Œ ìˆ˜í–‰)
      - name: Type check
        run: npx tsc --noEmit

  # ----- CD ë‹¨ê³„: ì»¨í…Œì´ë„ˆ ë¹Œë“œ/í‘¸ì‹œ ë° ECS ë°°í¬ -----
  # âš ï¸ ìˆœì„œ ì œì–´: ci â†’ build-docker â†’ deploy-ecs ìˆœì„œë¡œ ì‹¤í–‰ë¨
  build-docker:
    name: Build Docker image and push to ECR
    runs-on: ubuntu-latest
    needs: ci                      # CI í†µê³¼ í›„ì—ë§Œ ë¹Œë“œ ì§„í–‰
    # Access Key ë°©ì‹ì€ OIDC ê¶Œí•œì´ í•„ìš” ì—†ìŠµë‹ˆë‹¤. (id-token ì œê±°)
    # permissions:
      # contents: read

    env:
      AWS_REGION: ap-northeast-2              # ë°°í¬ ë¦¬ì „
      ECR_REPOSITORY: minimal-project         # ECR ë¦¬í¬ì§€í† ë¦¬ ì´ë¦„ (ì‚¬ì „ ìƒì„± í•„ìš”)
      IMAGE_TAG: ${{ github.sha }}            # ì´ë¯¸ì§€ íƒœê·¸(ì»¤ë°‹ SHA ì‚¬ìš©)
      ECS_CLUSTER: cluster-nestjs-second      # ì´ì „ be-ci.yml ê¸°ì¤€ ì‹¤ì œ ECS í´ëŸ¬ìŠ¤í„°ëª…
      ECS_SERVICE: app  # ì´ì „ be-ci.yml ê¸°ì¤€ ì‹¤ì œ ECS ì„œë¹„ìŠ¤ëª…

    steps:
      # 1) ì €ì¥ì†Œ ì²´í¬ì•„ì›ƒ (ë„ì»¤ ì»¨í…ìŠ¤íŠ¸ë¡œ ì‚¬ìš©)
      - name: Checkout
        uses: actions/checkout@v4

      # 2) Buildx ì„¤ì • (docker-container ë“œë¼ì´ë²„) â€” GHA ìºì‹œ ì‚¬ìš©ì„ ìœ„í•´ í•„ìš”
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          install: true
          driver: docker-container

      # 3) AWS ìê²©ì¦ëª… êµ¬ì„± (Access Key ë°©ì‹). ë ˆí¬ ì‹œí¬ë¦¿ì— í‚¤ ë³´ê´€ í•„ìš”
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      # 4) ECR ë¡œê·¸ì¸ â€” docker/build-push-actionì´ ECRì— í‘¸ì‹œí•  ìˆ˜ ìˆë„ë¡ ë ˆì§€ìŠ¤íŠ¸ë¦¬ ë¡œê·¸ì¸
      - name: Login to Amazon ECR
        id: ecr
        uses: aws-actions/amazon-ecr-login@v2

      # 5) ì´ë¯¸ì§€ URI êµ¬ì„± â€” ì´í›„ ë‹¨ê³„ì—ì„œ ì°¸ì¡°í•˜ê¸° ì‰½ë„ë¡ í™˜ê²½ë³€ìˆ˜ì— ì €ì¥
      - name: Set image uri
        run: echo "IMAGE_URI=${{ steps.ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG }}" >> $GITHUB_ENV

      # 6) ë„ì»¤ ì´ë¯¸ì§€ ë¹Œë“œ ë° í‘¸ì‹œ â€” GHA ìºì‹œë¥¼ ì‚¬ìš©í•´ ë ˆì´ì–´ ìºì‹œ ì ì¤‘ë¥  í–¥ìƒ, ë°°í¬ ì‹œê°„ ë‹¨ì¶•
      # âš ï¸ ì¤‘ìš”: :latest íƒœê·¸ë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šê³  íŠ¹ì • ë²„ì „(ì»¤ë°‹ SHA)ë§Œ ì‚¬ìš©í•˜ì—¬ ì´ë¯¸ì§€ ë²„ì „ ì•ˆì •ì„± ë³´ì¥
      - name: Build and push (with cache)
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: ${{ env.IMAGE_URI }}    # íŠ¹ì • ë²„ì „ íƒœê·¸ë§Œ ì‚¬ìš© (ì»¤ë°‹ SHA ê¸°ë°˜)
          provenance: false             # SBOM/attestation ë¹„í™œì„±í™”(ì†ë„ ìš°ì„ ). í•„ìš” ì‹œ true
          cache-from: type=gha          # GitHub Actions ìºì‹œ ì‚¬ìš© (ë ˆì´ì–´ ë³µì›)
          cache-to: type=gha,mode=max   # ë ˆì´ì–´ ì €ì¥ (ìµœëŒ€ ìºì‹œ í™œìš©)

      # 6-1) ì´ë¯¸ì§€ í‘¸ì‹œ í™•ì¸ (ì´ë¯¸ì§€ ë²„ì „ ì•ˆì •ì„± ë³´ì¥)
      - name: Verify image exists in ECR
        run: |
          echo "ğŸ” Verifying image exists in ECR..."
          aws ecr describe-images \
            --repository-name ${{ env.ECR_REPOSITORY }} \
            --image-ids imageTag=${{ env.IMAGE_TAG }} \
            --region ${{ env.AWS_REGION }} \
            --query 'imageDetails[0].{Digest:imageDigest,PushedAt:imagePushedAt}' \
            --output json
          
          if [ $? -ne 0 ]; then
            echo "âŒ Error: Image ${{ env.IMAGE_URI }} not found in ECR"
            exit 1
          fi
          
          echo "âœ… Image verified successfully in ECR"

      # 6-2) ì´ë¯¸ì§€ URIë¥¼ ì¶œë ¥ (ë‹¤ìŒ jobì—ì„œ ì‚¬ìš©)
      - name: Output image URI
        run: echo "IMAGE_URI=${{ env.IMAGE_URI }}" >> $GITHUB_OUTPUT
        id: image_output

  # ----- ë°°í¬ ë‹¨ê³„: ECSì— ë°°í¬ (ë¹Œë“œ ì™„ë£Œ í›„ ì‹¤í–‰) -----
  deploy-ecs:
    name: Deploy to ECS
    runs-on: ubuntu-latest
    needs: build-docker            # Docker ë¹Œë“œ ì™„ë£Œ í›„ì—ë§Œ ë°°í¬ ì§„í–‰

    env:
      AWS_REGION: ap-northeast-2
      ECR_REPOSITORY: minimal-project
      IMAGE_TAG: ${{ github.sha }}
      ECS_CLUSTER: cluster-nestjs-second
      ECS_SERVICE: app

    steps:
      # 1) ì €ì¥ì†Œ ì²´í¬ì•„ì›ƒ (íƒœìŠ¤í¬ ì •ì˜ íŒŒì¼ í•„ìš”)
      - name: Checkout
        uses: actions/checkout@v4

      # 2) AWS ìê²©ì¦ëª… êµ¬ì„±
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      # 3) ECR ë¡œê·¸ì¸ (ì´ë¯¸ì§€ URI í™•ì¸ìš©)
      - name: Login to Amazon ECR
        id: ecr
        uses: aws-actions/amazon-ecr-login@v2

      # 4) ì´ë¯¸ì§€ URI êµ¬ì„± (ë¹Œë“œëœ ì´ë¯¸ì§€ ì‚¬ìš©)
      - name: Set image uri
        run: echo "IMAGE_URI=${{ steps.ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG }}" >> $GITHUB_ENV

      # 5) ì´ë¯¸ì§€ ì¡´ì¬ í™•ì¸ (ì´ë¯¸ì§€ ë²„ì „ ì•ˆì •ì„± ë³´ì¥)
      - name: Verify image exists in ECR before deployment
        run: |
          echo "ğŸ” Verifying image exists in ECR before deployment..."
          aws ecr describe-images \
            --repository-name ${{ env.ECR_REPOSITORY }} \
            --image-ids imageTag=${{ env.IMAGE_TAG }} \
            --region ${{ env.AWS_REGION }} \
            --query 'imageDetails[0].{Digest:imageDigest,PushedAt:imagePushedAt}' \
            --output json
          
          if [ $? -ne 0 ]; then
            echo "âŒ Error: Image ${{ env.IMAGE_URI }} not found in ECR"
            echo "   This can happen if the image was deleted or never pushed successfully."
            exit 1
          fi
          
          echo "âœ… Image verified successfully in ECR"

      # 6) íƒœìŠ¤í¬ ì •ì˜ ë Œë”ë§ â€” ì»¨í…Œì´ë„ˆ ì´ë¯¸ì§€ë§Œ êµì²´ëœ ìƒˆë¡œìš´ íƒœìŠ¤í¬ ì •ì˜ ìƒì„±
      # âš ï¸ ì¤‘ìš”: :latest íƒœê·¸ ëŒ€ì‹  íŠ¹ì • ë²„ì „(ì»¤ë°‹ SHA)ì„ ì‚¬ìš©í•˜ì—¬ ì´ë¯¸ì§€ ë²„ì „ ì•ˆì •ì„± ë³´ì¥
      - name: Render task definition
        id: taskdef
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: ecs-task-def.json
          container-name: app
          image: ${{ env.IMAGE_URI }}   # íŠ¹ì • ë²„ì „ íƒœê·¸ ì‚¬ìš© (ì˜ˆ: .../minimal-project:abc123def)

      # 6-1) ë Œë”ë§ëœ íƒœìŠ¤í¬ ì •ì˜ í™•ì¸ (ë””ë²„ê¹…ìš©) - :latest íƒœê·¸ ì‚¬ìš© ì—¬ë¶€ í™•ì¸
      - name: Verify task definition (check for :latest tag)
        run: |
          echo "ğŸ” Verifying rendered task definition..."
          IMAGE_URI=$(echo "${{ steps.taskdef.outputs.task-definition }}" | jq -r '.containerDefinitions[0].image')
          echo "Image URI: $IMAGE_URI"
          
          # :latest íƒœê·¸ ì‚¬ìš© ì—¬ë¶€ í™•ì¸
          if echo "$IMAGE_URI" | grep -q ":latest"; then
            echo "âŒ Error: Task definition uses :latest tag. This violates AWS ECS image version stability requirements."
            echo "   Please use a specific version tag instead."
            exit 1
          fi
          
          # íŠ¹ì • ë²„ì „ íƒœê·¸ í™•ì¸
          if echo "$IMAGE_URI" | grep -qE ":[a-f0-9]{40}$"; then
            echo "âœ… Task definition uses specific version tag (commit SHA)"
          elif echo "$IMAGE_URI" | grep -qE ":[0-9]+\.[0-9]+\.[0-9]+"; then
            echo "âœ… Task definition uses specific version tag (semantic version)"
          else
            echo "âš ï¸ Warning: Tag format is not standard. Please verify the tag is a specific version."
          fi
          
          echo "âœ… Task definition verification passed"

      # 7) ECS ì„œë¹„ìŠ¤ ë„¤íŠ¸ì›Œí¬ êµ¬ì„± ì—…ë°ì´íŠ¸ (í¼ë¸”ë¦­ IP í™œì„±í™”)
      - name: Update ECS service network configuration (enable public IP)
        run: |
          # í˜„ì¬ ì„œë¹„ìŠ¤ì˜ ë„¤íŠ¸ì›Œí¬ êµ¬ì„± ê°€ì ¸ì˜¤ê¸°
          SUBNETS=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --region ${{ env.AWS_REGION }} \
            --query 'services[0].networkConfiguration.awsvpcConfiguration.subnets' \
            --output text)
          
          SECURITY_GROUPS=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --region ${{ env.AWS_REGION }} \
            --query 'services[0].networkConfiguration.awsvpcConfiguration.securityGroups' \
            --output text)
          
          # ì„œë¸Œë„·ê³¼ ë³´ì•ˆ ê·¸ë£¹ì´ ìˆìœ¼ë©´ ë„¤íŠ¸ì›Œí¬ êµ¬ì„± ì—…ë°ì´íŠ¸
          if [ ! -z "$SUBNETS" ] && [ "$SUBNETS" != "None" ]; then
            # ì„œë¸Œë„·ì„ ì‰¼í‘œë¡œ êµ¬ë¶„ëœ ë¬¸ìì—´ë¡œ ë³€í™˜
            SUBNET_IDS=$(echo $SUBNETS | tr '\t' ' ' | tr -s ' ' | sed 's/^ *//;s/ *$//' | tr ' ' ',')
            
            # ë³´ì•ˆ ê·¸ë£¹ì´ ìˆìœ¼ë©´ í¬í•¨, ì—†ìœ¼ë©´ ì œì™¸
            if [ ! -z "$SECURITY_GROUPS" ] && [ "$SECURITY_GROUPS" != "None" ]; then
              SG_IDS=$(echo $SECURITY_GROUPS | tr '\t' ' ' | tr -s ' ' | sed 's/^ *//;s/ *$//' | tr ' ' ',')
              aws ecs update-service \
                --cluster ${{ env.ECS_CLUSTER }} \
                --service ${{ env.ECS_SERVICE }} \
                --network-configuration "awsvpcConfiguration={subnets=[$SUBNET_IDS],securityGroups=[$SG_IDS],assignPublicIp=ENABLED}" \
                --region ${{ env.AWS_REGION }} \
                --query 'service.networkConfiguration' \
                --output json || echo "âš ï¸ Network configuration update failed or already correct"
            else
              aws ecs update-service \
                --cluster ${{ env.ECS_CLUSTER }} \
                --service ${{ env.ECS_SERVICE }} \
                --network-configuration "awsvpcConfiguration={subnets=[$SUBNET_IDS],assignPublicIp=ENABLED}" \
                --region ${{ env.AWS_REGION }} \
                --query 'service.networkConfiguration' \
                --output json || echo "âš ï¸ Network configuration update failed or already correct"
            fi
          else
            echo "âš ï¸ Could not retrieve subnet configuration. Please update service manually in AWS Console."
          fi

      # 8) ê¸°ì¡´ íƒœìŠ¤í¬ í™•ì¸ ë° ì •ë¦¬ (ENI ì˜¤ë¥˜ ë°©ì§€)
      - name: Check and cleanup stale tasks
        run: |
          echo "ğŸ” Checking for stale tasks..."
          
          # ì‹¤í–‰ ì¤‘ì´ê±°ë‚˜ ì¤‘ì§€ëœ íƒœìŠ¤í¬ í™•ì¸
          STALE_TASKS=$(aws ecs list-tasks \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service-name ${{ env.ECS_SERVICE }} \
            --desired-status STOPPED \
            --region ${{ env.AWS_REGION }} \
            --query 'taskArns' \
            --output json 2>/dev/null || echo "[]")
          
          echo "Found stale tasks: $STALE_TASKS"
          
          # ì„œë¹„ìŠ¤ ê°•ì œ ìƒˆ ë°°í¬ (ê¸°ì¡´ íƒœìŠ¤í¬ ì •ë¦¬)
          echo "ğŸ”„ Forcing new deployment to cleanup stale tasks..."
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_SERVICE }} \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }} \
            --query 'service.{ServiceName:serviceName,Status:status}' \
            --output json || echo "âš ï¸ Warning: Could not force new deployment"

      # 9) ECS ë°°í¬ â€” ìƒˆ íƒœìŠ¤í¬ ì •ì˜ë¥¼ ì„œë¹„ìŠ¤ì— ì ìš©í•˜ê³  ì•ˆì •í™”ê¹Œì§€ ëŒ€ê¸°
      - name: Deploy to ECS
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: ${{ steps.taskdef.outputs.task-definition }}
          service: ${{ env.ECS_SERVICE }}
          cluster: ${{ env.ECS_CLUSTER }}
          wait-for-service-stability: true
          force-new-deployment: true  # ê°•ì œ ìƒˆ ë°°í¬ (ENI ì˜¤ë¥˜ ë°©ì§€)

      # (ì˜µì…˜) ë°°í¬ ê²°ê³¼ ì¶œë ¥
      - name: Deployment summary
        run: |
          echo "âœ… Deployment completed successfully"
          echo "Image: ${{ env.IMAGE_URI }}"
          echo "Service: ${{ env.ECS_SERVICE }}"
          echo "Cluster: ${{ env.ECS_CLUSTER }}"


